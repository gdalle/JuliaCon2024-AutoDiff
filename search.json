[
  {
    "objectID": "index.html#motivation",
    "href": "index.html#motivation",
    "title": "Gradients for everyone",
    "section": "Motivation",
    "text": "Motivation\n\n\n\n\n\n\nWhat is a derivative?\n\n\nA linear approximation of a function around a point.\n\n\n\n\n\n\n\n\n\nWhy do we care?\n\n\nDerivatives of computer code are essential in optimization and machine learning.\n\n\n\n\n\n\n\n\n\nWhat do I need to do?\n\n\nNot much: with Automatic Differentiation (AD), derivatives are easy to compute!\n\n\n\n\n\nWe’re more specifically talking about functions expressed as programs!"
  },
  {
    "objectID": "index.html#three-types-of-ad-users",
    "href": "index.html#three-types-of-ad-users",
    "title": "Gradients for everyone",
    "section": "Three types of AD users",
    "text": "Three types of AD users\n\nPackage users want to differentiate through functions\nPackage developers want to write differentiable functions\nBackend developers want to create new AD systems"
  },
  {
    "objectID": "index.html#python-vs.-julia-user-experience",
    "href": "index.html#python-vs.-julia-user-experience",
    "title": "Gradients for everyone",
    "section": "Python vs. Julia: user experience",
    "text": "Python vs. Julia: user experience\n\n\nImagine we need to use two packages: one for Foo, one for Bar\n\nIn Python, user first picks a framework, basically a DSL in Python\n\n(-) “three language problem”: Python -&gt; JAX -&gt; C++\n(-) packages need to be rewritten for each framework\n(+) compatibility between packages in an ecosystem is almost guaranteed\n(+) user doesn’t need to understand AD at all\n\nIn Julia, only one Foo and Bar package need to exist\n\n(+) efforts can be “centralized”\n(-) compatibility with backends is up to the package developers\n\noften left implicit, must be documented\n\n(-) puts burden on user to understand AD\n\notherwise hard to understand for where constraints come from\n\n\nIdeally, things would “just work”"
  },
  {
    "objectID": "index.html#python-vs.-julia-developers",
    "href": "index.html#python-vs.-julia-developers",
    "title": "Gradients for everyone",
    "section": "Python vs. Julia: developers",
    "text": "Python vs. Julia: developers\n\n\n\nLet’s talk about the developer experience\nIn Python, things are simple and boring: JAX, PyTorch or TensorFlow\nIn Julia, things are complicated and fun\n\ndozens of backends\noverview at https://juliadiff.org/"
  },
  {
    "objectID": "index.html#python-vs.-julia-developers-1",
    "href": "index.html#python-vs.-julia-developers-1",
    "title": "Gradients for everyone",
    "section": "Python vs. Julia: developers",
    "text": "Python vs. Julia: developers\n\n\n\nBoth ecosystem come with constraints, but “arrow points in different direction”\nPython\n\ndevs are aware of these before starting to write code\ne.g. JAX doesn’t allow inplace mutation\n\nJulia\n\nusually, constrains come after writing code: e.g. making code of a physics simulation differentiable\nunless you already had a specific backend in mind when working on your package, you will have to refactor\n⚠️ contraints of some backends are conflict with performant Julia code\n\ne.g. no in-place mutation in Zygote\n\n\nA lot of folklore and hidden knowledge, hard to see straight\nHow to choose an AD backend and make it work?"
  },
  {
    "objectID": "index.html#various-flavors-of-differentiation",
    "href": "index.html#various-flavors-of-differentiation",
    "title": "Gradients for everyone",
    "section": "Various flavors of differentiation",
    "text": "Various flavors of differentiation\n\nManual: work out \\(f'\\) by hand\nNumeric: \\(f'(x) \\approx \\frac{f(x+\\varepsilon) - f(x)}{\\varepsilon}\\)\nSymbolic: code a formula for \\(f\\), get a formula for \\(f'\\)\nAutomatic: code a program for \\(f\\), get a value for \\(f'(x)\\)\n\n\n\nManual aka blood, sweat and tears\nNumeric aka finite differences\nSymbolic aka computer algebra\nAutomatic aka algorithmic\n\nfinite differences are also automatic, compute JVPs"
  },
  {
    "objectID": "index.html#automatic-differentiation",
    "href": "index.html#automatic-differentiation",
    "title": "Gradients for everyone",
    "section": "Automatic differentiation",
    "text": "Automatic differentiation\nThree key ideas (Griewank and Walther 2008):\n\nPrograms are composition chains (or DAGs) of many functions\nJacobian of \\(f = f_L \\circ \\dots \\circ f_2 \\circ f_1\\) given by the chain rule: \\[\nJ = J_L J_{L-1} \\dots J_2 J_1\n\\]\nAvoid materializing full Jacobians with matrix-vector products: we only need \\(Jv\\) and \\(v^\\top J\\)\n\n\n\nMost notably for point 3, a matrix-vector-product with the i-th standard basis vector returns the i-th column of the matrix"
  },
  {
    "objectID": "index.html#forward-mode",
    "href": "index.html#forward-mode",
    "title": "Gradients for everyone",
    "section": "Forward mode",
    "text": "Forward mode\nJacobian-Vector Products (JVPs), aka pushforwards, are naturally decomposed from \\(1\\) to \\(L\\): \\[\nJ v = J_L (J_{L-1}(\\dots J_2(J_1 v)))\n\\]\nFor \\(f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m\\), the \\(m \\times n\\) Jacobian requires \\(n\\) JVPs: one per input dimension.\n\n\n\n\n\n\nSpecial case\n\n\nThe derivative of \\(f : \\mathbb{R} \\rightarrow \\mathbb{R}^m\\) requires just one JVP."
  },
  {
    "objectID": "index.html#reverse-mode",
    "href": "index.html#reverse-mode",
    "title": "Gradients for everyone",
    "section": "Reverse mode",
    "text": "Reverse mode\nVector-Jacobian Products (JVPs), aka pullbacks, are naturally decomposed from \\(L\\) to \\(1\\): \\[\nv^\\top J = (((v^\\top J_L) J_{L-1}) \\dots J_2)J_1\n\\]\nFor \\(f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m\\), the \\(m \\times n\\) Jacobian requires \\(m\\) VJPs: one per output dimension.\n\n\n\n\n\n\nSpecial case\n\n\nThe gradient of \\(f : \\mathbb{R}^n \\rightarrow \\mathbb{R}\\) requires just one VJP."
  },
  {
    "objectID": "index.html#implementation-details",
    "href": "index.html#implementation-details",
    "title": "Gradients for everyone",
    "section": "Implementation details",
    "text": "Implementation details\n\n\nForward mode\nForward sweep only.\nOften based on dual numbers.\nLow memory cost.\n\nReverse mode\nForward sweep + reverse sweep.\nOften based on tapes.\nHigh memory cost.\n\n\n\nJacobians/JVPs/VJPs are computed around a “point of linearization”\n\nin forward-mode, the order of the JVP evaluation is the same as the the forward pass through f\nin reverse-mode, the order is reversed -&gt; we need tape"
  },
  {
    "objectID": "index.html#why-so-many-backends",
    "href": "index.html#why-so-many-backends",
    "title": "Gradients for everyone",
    "section": "Why so many backends?",
    "text": "Why so many backends?\n\nConflicting paradigms:\n\nnumeric vs. symbolic vs. algorithmic\noperator overloading vs. source-to-source (which source?)\n\nCover varying subsets of the language\nHistorical reasons: developed by different people"
  },
  {
    "objectID": "index.html#meaningful-criteria",
    "href": "index.html#meaningful-criteria",
    "title": "Gradients for everyone",
    "section": "Meaningful criteria",
    "text": "Meaningful criteria\n\nDoes this AD backend execute without error?\nDoes it return the right derivative?\nDoes it run fast enough for me?"
  },
  {
    "objectID": "index.html#a-simple-decision-tree",
    "href": "index.html#a-simple-decision-tree",
    "title": "Gradients for everyone",
    "section": "A simple decision tree",
    "text": "A simple decision tree\n\nFollow recommendations of high-level library (e.g. Flux).\nOtherwise, choose mode based on input and output dimensions.\nTry the most battle-tested backends: ForwardDiff or Enzyme in forward mode, Zygote or Enzyme in reverse mode.\nIf nothing works, fall back on finite differences."
  },
  {
    "objectID": "index.html#typical-forwarddiff-failure",
    "href": "index.html#typical-forwarddiff-failure",
    "title": "Gradients for everyone",
    "section": "Typical ForwardDiff failure",
    "text": "Typical ForwardDiff failure\n\nimport ForwardDiff\n\nbadcopy(x) = copyto!(zeros(size(x)), x)\n\nForwardDiff.jacobian(badcopy, ones(2))\n\nMethodError: MethodError(Float64, (Dual{ForwardDiff.Tag{typeof(Main.Notebook.badcopy), Float64}}(1.0,1.0,0.0),), 0x0000000000007b04)\nMethodError: no method matching Float64(::ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2})\n\nClosest candidates are:\n  (::Type{T})(::Real, !Matched::RoundingMode) where T&lt;:AbstractFloat\n   @ Base rounding.jl:207\n  (::Type{T})(::T) where T&lt;:Number\n   @ Core boot.jl:792\n  Float64(!Matched::IrrationalConstants.Loghalf)\n   @ IrrationalConstants ~/.julia/packages/IrrationalConstants/vp5v4/src/macro.jl:112\n  ...\n\nStacktrace:\n  [1] convert(::Type{Float64}, x::ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2})\n    @ Base ./number.jl:7\n  [2] setindex!(A::Vector{Float64}, x::ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}, i1::Int64)\n    @ Base ./array.jl:1021\n  [3] _unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::Vector{ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}}, soffs::Int64, n::Int64)\n    @ Base ./array.jl:299\n  [4] unsafe_copyto!\n    @ ./array.jl:353 [inlined]\n  [5] _copyto_impl!\n    @ ./array.jl:376 [inlined]\n  [6] copyto!\n    @ ./array.jl:363 [inlined]\n  [7] copyto!\n    @ ./array.jl:385 [inlined]\n  [8] badcopy(x::Vector{ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}})\n    @ Main.Notebook ~/work/JuliaCon2024-AutoDiff/JuliaCon2024-AutoDiff/index.qmd:252\n  [9] vector_mode_dual_eval!\n    @ ~/.julia/packages/ForwardDiff/PcZ48/src/apiutils.jl:24 [inlined]\n [10] vector_mode_jacobian(f::typeof(badcopy), x::Vector{Float64}, cfg::ForwardDiff.JacobianConfig{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2, Vector{ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}}})\n    @ ForwardDiff ~/.julia/packages/ForwardDiff/PcZ48/src/jacobian.jl:125\n [11] jacobian(f::Function, x::Vector{Float64}, cfg::ForwardDiff.JacobianConfig{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2, Vector{ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}}}, ::Val{true})\n    @ ForwardDiff ~/.julia/packages/ForwardDiff/PcZ48/src/jacobian.jl:21\n [12] jacobian(f::Function, x::Vector{Float64}, cfg::ForwardDiff.JacobianConfig{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2, Vector{ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}}})\n    @ ForwardDiff ~/.julia/packages/ForwardDiff/PcZ48/src/jacobian.jl:19\n [13] top-level scope\n    @ ~/work/JuliaCon2024-AutoDiff/JuliaCon2024-AutoDiff/index.qmd:254"
  },
  {
    "objectID": "index.html#forwarddiff-troubleshooting",
    "href": "index.html#forwarddiff-troubleshooting",
    "title": "Gradients for everyone",
    "section": "ForwardDiff troubleshooting",
    "text": "ForwardDiff troubleshooting\nAllow numbers of type Dual in your functions.\n\ngoodcopy(x::AbstractArray{&lt;:Real}) = copyto!(zeros(eltype(x), size(x)), x)\n\nForwardDiff.jacobian(goodcopy, ones(2))\n\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0"
  },
  {
    "objectID": "index.html#typical-zygote-failure",
    "href": "index.html#typical-zygote-failure",
    "title": "Gradients for everyone",
    "section": "Typical Zygote failure",
    "text": "Typical Zygote failure\n\nimport Zygote\n\nZygote.jacobian(badcopy, ones(2))\n\nErrorException: ErrorException(\"Mutating arrays is not supported -- called copyto!(Vector{Float64}, ...)\\nThis error occurs when you ask Zygote to differentiate operations that change\\nthe elements of arrays in place (e.g. setting values with x .= ...)\\n\\nPossible fixes:\\n- avoid mutating operations (preferred)\\n- or read the documentation and solutions for this error\\n  https://fluxml.ai/Zygote.jl/latest/limitations\\n\")\nMutating arrays is not supported -- called copyto!(Vector{Float64}, ...)\nThis error occurs when you ask Zygote to differentiate operations that change\nthe elements of arrays in place (e.g. setting values with x .= ...)\n\nPossible fixes:\n- avoid mutating operations (preferred)\n- or read the documentation and solutions for this error\n  https://fluxml.ai/Zygote.jl/latest/limitations\n\nStacktrace:\n  [1] error(s::String)\n    @ Base ./error.jl:35\n  [2] _throw_mutation_error(f::Function, args::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/lib/array.jl:70\n  [3] (::Zygote.var\"#543#544\"{Vector{Float64}})(::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/lib/array.jl:85\n  [4] (::Zygote.var\"#2633#back#545\"{Zygote.var\"#543#544\"{Vector{Float64}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/ZygoteRules/M4xmc/src/adjoint.jl:72\n  [5] badcopy\n    @ ~/work/JuliaCon2024-AutoDiff/JuliaCon2024-AutoDiff/index.qmd:252 [inlined]\n  [6] (::Zygote.Pullback{Tuple{typeof(badcopy), Vector{Float64}}, Tuple{Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}, Zygote.var\"#2633#back#545\"{Zygote.var\"#543#544\"{Vector{Float64}}}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/compiler/interface2.jl:0\n  [7] (::Zygote.var\"#291#292\"{Tuple{Tuple{Nothing}}, Zygote.Pullback{Tuple{typeof(badcopy), Vector{Float64}}, Tuple{Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}, Zygote.var\"#2633#back#545\"{Zygote.var\"#543#544\"{Vector{Float64}}}}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/lib/lib.jl:206\n  [8] (::Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing}}, Zygote.Pullback{Tuple{typeof(badcopy), Vector{Float64}}, Tuple{Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}, Zygote.var\"#2633#back#545\"{Zygote.var\"#543#544\"{Vector{Float64}}}}}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/ZygoteRules/M4xmc/src/adjoint.jl:72\n  [9] call_composed\n    @ ./operators.jl:1045 [inlined]\n [10] (::Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Any})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/compiler/interface2.jl:0\n [11] call_composed\n    @ ./operators.jl:1044 [inlined]\n [12] #_#103\n    @ ./operators.jl:1041 [inlined]\n [13] (::Zygote.Pullback{Tuple{Base.var\"##_#103\", @Kwargs{}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}}, Tuple{Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:outer, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(Zygote._jvec)}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(Zygote._jvec)}, Tuple{Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(Zygote._jvec)}, Tuple{}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:inner, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(badcopy)}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(badcopy)}, Tuple{Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(badcopy)}, Tuple{}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}}, Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing}, Tuple{Nothing}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}}}}, Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(Zygote._jvec), typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Any}, Zygote.var\"#2029#back#213\"{Zygote.var\"#back#211\"{2, 1, Zygote.Context{false}, typeof(Zygote._jvec)}}, Zygote.Pullback{Tuple{typeof(Zygote._jvec), Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(vec), Vector{Float64}}, Tuple{}}}}, Zygote.var\"#2141#back#281\"{Zygote.var\"#277#280\"}}}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/compiler/interface2.jl:0\n [14] #291\n    @ ~/.julia/packages/Zygote/nsBv0/src/lib/lib.jl:206 [inlined]\n [15] #2169#back\n    @ ~/.julia/packages/ZygoteRules/M4xmc/src/adjoint.jl:72 [inlined]\n [16] ComposedFunction\n    @ ./operators.jl:1041 [inlined]\n [17] (::Zygote.Pullback{Tuple{ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, Vector{Float64}}, Tuple{Zygote.var\"#2366#back#419\"{Zygote.var\"#pairs_namedtuple_pullback#418\"{(), @NamedTuple{}}}, Zygote.Pullback{Tuple{Type{NamedTuple}}, Tuple{}}, Zygote.var\"#2013#back#204\"{typeof(identity)}, Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing, Nothing}, Tuple{Nothing}}, Zygote.Pullback{Tuple{Base.var\"##_#103\", @Kwargs{}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}}, Tuple{Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:outer, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(Zygote._jvec)}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(Zygote._jvec)}, Tuple{Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(Zygote._jvec)}, Tuple{}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:inner, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(badcopy)}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(badcopy)}, Tuple{Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(badcopy)}, Tuple{}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}}, Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing}, Tuple{Nothing}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}}}}, Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(Zygote._jvec), typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Any}, Zygote.var\"#2029#back#213\"{Zygote.var\"#back#211\"{2, 1, Zygote.Context{false}, typeof(Zygote._jvec)}}, Zygote.Pullback{Tuple{typeof(Zygote._jvec), Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(vec), Vector{Float64}}, Tuple{}}}}, Zygote.var\"#2141#back#281\"{Zygote.var\"#277#280\"}}}}}}}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/compiler/interface2.jl:0\n [18] (::Zygote.var\"#75#76\"{Zygote.Pullback{Tuple{ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, Vector{Float64}}, Tuple{Zygote.var\"#2366#back#419\"{Zygote.var\"#pairs_namedtuple_pullback#418\"{(), @NamedTuple{}}}, Zygote.Pullback{Tuple{Type{NamedTuple}}, Tuple{}}, Zygote.var\"#2013#back#204\"{typeof(identity)}, Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing, Nothing}, Tuple{Nothing}}, Zygote.Pullback{Tuple{Base.var\"##_#103\", @Kwargs{}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}}, Tuple{Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:outer, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(Zygote._jvec)}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(Zygote._jvec)}, Tuple{Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(Zygote._jvec)}, Tuple{}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:inner, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(badcopy)}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(badcopy)}, Tuple{Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(badcopy)}, Tuple{}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}}, Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing}, Tuple{Nothing}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}}}}, Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(Zygote._jvec), typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Any}, Zygote.var\"#2029#back#213\"{Zygote.var\"#back#211\"{2, 1, Zygote.Context{false}, typeof(Zygote._jvec)}}, Zygote.Pullback{Tuple{typeof(Zygote._jvec), Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(vec), Vector{Float64}}, Tuple{}}}}, Zygote.var\"#2141#back#281\"{Zygote.var\"#277#280\"}}}}}}}}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/compiler/interface.jl:91\n [19] withjacobian(f::Function, args::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/lib/grad.jl:150\n [20] jacobian(f::Function, args::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/lib/grad.jl:128\n [21] top-level scope\n    @ ~/work/JuliaCon2024-AutoDiff/JuliaCon2024-AutoDiff/index.qmd:280"
  },
  {
    "objectID": "index.html#zygote-troubleshooting",
    "href": "index.html#zygote-troubleshooting",
    "title": "Gradients for everyone",
    "section": "Zygote troubleshooting",
    "text": "Zygote troubleshooting\nDefine a custom rule with ChainRulesCore:\n\nusing ChainRulesCore, LinearAlgebra\n\nbadcopy2(x) = badcopy(x)\n\nfunction ChainRulesCore.rrule(::typeof(badcopy2), x)\n    @info \"My rule is called\"\n    y = badcopy2(x)  # primal value\n    function badcopy2_pullback(dy)\n    @info \"My pullback is called\"\n        df = NoTangent()\n        dx = I' * dy # Vector-Jacobian product\n        return (df, dx)\n    end\n    return y, badcopy2_pullback\nend\n\nZygote.jacobian(badcopy2, ones(2))\n\n[ Info: My rule is called\n[ Info: My pullback is called\n[ Info: My pullback is called\n\n\n([1.0 0.0; 0.0 1.0],)"
  },
  {
    "objectID": "index.html#typical-enzyme-failure",
    "href": "index.html#typical-enzyme-failure",
    "title": "Gradients for everyone",
    "section": "Typical Enzyme failure",
    "text": "Typical Enzyme failure\n\nimport Enzyme\n\nEnzyme.autodiff(\n  Enzyme.Forward,\n  badcopy,\n  Enzyme.Active(ones(2))\n)\n\nErrorException: ErrorException(\"Unsupported Active{Vector{Float64}}, consider Duplicated or Const\")\nUnsupported Active{Vector{Float64}}, consider Duplicated or Const\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] EnzymeCore.Active(x::Vector{Float64})\n   @ EnzymeCore ~/.julia/packages/EnzymeCore/a2poZ/src/EnzymeCore.jl:49\n [3] top-level scope\n   @ ~/work/JuliaCon2024-AutoDiff/JuliaCon2024-AutoDiff/index.qmd:320"
  },
  {
    "objectID": "index.html#enzyme-troubleshooting",
    "href": "index.html#enzyme-troubleshooting",
    "title": "Gradients for everyone",
    "section": "Enzyme troubleshooting",
    "text": "Enzyme troubleshooting\nPay attention to type stability, temporary storage and activity annotations (see the FAQ).\nEnzyme.autodiff(\n  Enzyme.Forward,\n  badcopy,\n  Enzyme.Duplicated(ones(2), zeros(2))\n)"
  },
  {
    "objectID": "index.html#goals",
    "href": "index.html#goals",
    "title": "Gradients for everyone",
    "section": "Goals",
    "text": "Goals\n\nDifferentiationInterface (DI) offers a common syntax for all AD backends1\nAD users can compare correctness and performance without reading each documentation\nAD developers get access to a wider user base\n\n\n\n\n\n\n\nThe fine print\n\n\nDI may be slower than a direct call to the backend’s API (mostly with Enzyme).\n\n\n\ninspired by AbstractDifferentiation"
  },
  {
    "objectID": "index.html#supported-packages",
    "href": "index.html#supported-packages",
    "title": "Gradients for everyone",
    "section": "Supported packages",
    "text": "Supported packages\n\n\n\n\nChainRulesCore\nDiffractor\nEnzyme\nFastDifferentiation\nFiniteDiff\nFiniteDifferences\nForwardDiff\n\n\n\nPolyesterForwardDiff\nReverseDiff\nSymbolics\nTapir\nTracker\nZygote"
  },
  {
    "objectID": "index.html#getting-started-with-di",
    "href": "index.html#getting-started-with-di",
    "title": "Gradients for everyone",
    "section": "Getting started with DI",
    "text": "Getting started with DI\nStep 1: load the necessary packages\n\nusing DifferentiationInterface\nimport ForwardDiff, Enzyme, Zygote\n\nf(x) = sum(abs2, x)\nx = [1.0, 2.0, 3.0, 4.0]\n\nStep 2: Combine DI’s operators with a backend from ADTypes\n\nvalue_and_gradient(f, AutoForwardDiff(), x)\n\n(30.0, [2.0, 4.0, 6.0, 8.0])\n\n\n\nvalue_and_gradient(f, AutoEnzyme(), x)\n\n(30.0, [2.0, 4.0, 6.0, 8.0])\n\n\n\nvalue_and_gradient(f, AutoZygote(), x)\n\n(30.0, [2.0, 4.0, 6.0, 8.0])\n\n\nStep 3: Increase performance via DI’s preparation mechanism"
  },
  {
    "objectID": "index.html#features-of-di",
    "href": "index.html#features-of-di",
    "title": "Gradients for everyone",
    "section": "Features of DI",
    "text": "Features of DI\n\nSupport for functions f(x) or f!(y, x) with scalar/array inputs & outputs\nEight standard operators: pushforward, pullback, derivative, gradient, jacobian, hvp, second_derivative, hessian\nOut-of-place and in-place versions\nCombine different backends using SecondOrder\nTranslate between backends using DifferentiateWith"
  },
  {
    "objectID": "index.html#differentiationinterfacetest",
    "href": "index.html#differentiationinterfacetest",
    "title": "Gradients for everyone",
    "section": "DifferentiationInterfaceTest",
    "text": "DifferentiationInterfaceTest\n\nSystematic tests for a variety of inputs and functions\nScenarios with weird arrays (static, GPU, sparse)\nType-stability checks\nAutomated benchmarks"
  },
  {
    "objectID": "index.html#sparse-ad-ecosystem",
    "href": "index.html#sparse-ad-ecosystem",
    "title": "Gradients for everyone",
    "section": "Sparse AD ecosystem",
    "text": "Sparse AD ecosystem\n\nSparseConnectivityTracer for sparsity pattern detection\nSparseMatrixColorings for matrix coloring\nDI for sparse Jacobians and Hessians (see tutorial)\n\n\nSparse AD with coloring (Gebremedhin, Manne, and Pothen 2005)"
  },
  {
    "objectID": "index.html#whats-next",
    "href": "index.html#whats-next",
    "title": "Gradients for everyone",
    "section": "What’s next?",
    "text": "What’s next?\nDI and its sparse AD ecosystem are brand new projects:\n\nTry them out in your code\nReport bugs or inefficiencies\nHelp us improve these packages!\n\n\n\n\n\n\n\nComing soon in DI (JuliaCon hackathon?)\n\n\nSupport for multiple arguments and non-array types."
  },
  {
    "objectID": "index.html#more-complex-settings",
    "href": "index.html#more-complex-settings",
    "title": "Gradients for everyone",
    "section": "More complex settings",
    "text": "More complex settings\n\nAD through a simple function\nAD through an integral?\nAD through an optimization solver?\nAD through a stochastic expectation?\n\nMore details in the book by Blondel and Roulet (2024)."
  },
  {
    "objectID": "index.html#take-home-message",
    "href": "index.html#take-home-message",
    "title": "Gradients for everyone",
    "section": "Take-home message",
    "text": "Take-home message\nComputing derivatives is easy, but each AD solution comes with its own limitations.\nLearn to recognize and overcome them, either as a user or as a developer."
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Gradients for everyone",
    "section": "References",
    "text": "References\n\n\nBlondel, Mathieu, and Vincent Roulet. 2024. “The Elements of Differentiable Programming.” arXiv. https://doi.org/10.48550/arXiv.2403.14606.\n\n\nGebremedhin, Assefaw Hadish, Fredrik Manne, and Alex Pothen. 2005. “What Color Is Your Jacobian? Graph Coloring for Computing Derivatives.” SIAM Review 47 (4): 629–705. https://doi.org/cmwds4.\n\n\nGriewank, Andreas, and Andrea Walther. 2008. Evaluating Derivatives: Principles and Techniques of Algorithmic Differentiation. 2nd ed. Philadelphia, PA: Society for Industrial and Applied Mathematics."
  }
]