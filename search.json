[
  {
    "objectID": "index.html#motivation",
    "href": "index.html#motivation",
    "title": "Gradients for everyone",
    "section": "Motivation",
    "text": "Motivation\n\n\n\n\n\n\nWhat is a derivative?\n\n\nA linear approximation of a function around a point.\n\n\n\n\n\n\n\n\n\nWhy do we care?\n\n\nDerivatives are essential in optimization and machine learning.\n\n\n\n\n\n\n\n\n\nWhat do I need to do?\n\n\nNot much: with Automatic Differentiation (AD), derivatives are very easy to compute!"
  },
  {
    "objectID": "index.html#differentiable-programming",
    "href": "index.html#differentiable-programming",
    "title": "Gradients for everyone",
    "section": "Differentiable programming",
    "text": "Differentiable programming\n\nDifferentiable programming is a programming paradigm in which complex computer programs (including those with control flows and data structures) can be differentiated end-to-end automatically, enabling gradient-based optimization of parameters in the program.\n\nFrom the book by Blondel and Roulet (2024)"
  },
  {
    "objectID": "index.html#three-types-of-ad-users",
    "href": "index.html#three-types-of-ad-users",
    "title": "Gradients for everyone",
    "section": "Three types of AD users",
    "text": "Three types of AD users\n\nPackage users want to differentiate through functions\nPackage developers want to write differentiable functions\nBackend developers want to create new AD systems"
  },
  {
    "objectID": "index.html#python-vs.-julia-users",
    "href": "index.html#python-vs.-julia-users",
    "title": "Gradients for everyone",
    "section": "Python vs. Julia: users",
    "text": "Python vs. Julia: users\n\n\nImagine we need to use two packages: one for Foo, one for Bar\n\nIn Python, both packages need to be rewritten for each framework\n\n(-) “three language problem”\n(+) compatibility between packages in an ecosystem is almost guaranteed\n\nIn Julia, only one Foo and Bar package need to exist\n\n(+) efforts can be “centralized”\n(-) compatibility with backends is up to the package developers\n\nmust be documented\nhard to understand for newcomers"
  },
  {
    "objectID": "index.html#python-vs.-julia-developers",
    "href": "index.html#python-vs.-julia-developers",
    "title": "Gradients for everyone",
    "section": "Python vs. Julia: developers",
    "text": "Python vs. Julia: developers\n\n\n\nIn Python, things are simple and boring: JAX, PyTorch or TensorFlow\nIn Julia, things are complicated and fun: https://juliadiff.org/\nA lot of folklore and hidden knowledge, hard to see straight\nHow to choose an AD backend and make it work?"
  },
  {
    "objectID": "index.html#python-vs.-julia-developers-1",
    "href": "index.html#python-vs.-julia-developers-1",
    "title": "Gradients for everyone",
    "section": "Python vs. Julia: developers",
    "text": "Python vs. Julia: developers"
  },
  {
    "objectID": "index.html#various-flavors-of-differentiation",
    "href": "index.html#various-flavors-of-differentiation",
    "title": "Gradients for everyone",
    "section": "Various flavors of differentiation",
    "text": "Various flavors of differentiation\n\nManual: work out \\(f'\\) by hand\nNumeric: \\(f'(x) \\approx \\frac{f(x+\\varepsilon) - f(x)}{\\varepsilon}\\)\nSymbolic: code a formula for \\(f\\), get a formula for \\(f'\\)\nAlgorithmic: code a program for \\(f\\), get a value for \\(f'(x)\\)\n\n\n\nManual aka blood, sweat and tears\nNumeric aka finite differences\nSymbolic aka computer algebra\nAlgorithmic aka autodiff"
  },
  {
    "objectID": "index.html#algorithmic-differentiation",
    "href": "index.html#algorithmic-differentiation",
    "title": "Gradients for everyone",
    "section": "Algorithmic differentiation",
    "text": "Algorithmic differentiation\nThree key ideas:\n\nPrograms are composition chains (or DAGs) of many functions\nJacobian of \\(f = f_L \\circ \\dots \\circ f_2 \\circ f_1\\) given by the chain rule: \\[\nJ = J_L J_{L-1} \\dots J_2 J_1\n\\]\nAvoid materializing full Jacobians with matrix-vector products"
  },
  {
    "objectID": "index.html#forward-mode",
    "href": "index.html#forward-mode",
    "title": "Gradients for everyone",
    "section": "Forward mode",
    "text": "Forward mode\nNatural decomposition of Jacobian-Vector Products (JVPs), aka pushforwards or forward rules: \\[\nJ v = J_L (J_{L-1}(\\dots J_2(J_1 v)))\n\\]\nFor \\(f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m\\), the \\(m \\times n\\) Jacobian requires \\(n\\) JVPs: one per input dimension.\n\n\n\n\n\n\nSpecial case\n\n\nThe derivative of \\(f : \\mathbb{R} \\rightarrow \\mathbb{R}^m\\) requires just one JVP."
  },
  {
    "objectID": "index.html#reverse-mode",
    "href": "index.html#reverse-mode",
    "title": "Gradients for everyone",
    "section": "Reverse mode",
    "text": "Reverse mode\nNatural decomposition of Vector-Jacobian Products (JVPs), aka pullbacks or reverse rules: \\[\nv^\\top J = (((v^\\top J_L) J_{L-1}) \\dots J_2)J_1\n\\]\nFor \\(f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m\\), the \\(m \\times n\\) Jacobian requires \\(m\\) VJPs: one per input dimension.\n\n\n\n\n\n\nSpecial case\n\n\nThe gradient of \\(f : \\mathbb{R}^n \\rightarrow \\mathbb{R}\\) requires just one VJP."
  },
  {
    "objectID": "index.html#implementation-details",
    "href": "index.html#implementation-details",
    "title": "Gradients for everyone",
    "section": "Implementation details",
    "text": "Implementation details\n\n\nForward mode\nForward sweep only.\nBased on dual numbers.\nLow memory cost.\n\nReverse mode\nForward sweep + reverse sweep.\nBased on tapes.\nHigh memory cost."
  },
  {
    "objectID": "index.html#why-so-many-backends",
    "href": "index.html#why-so-many-backends",
    "title": "Gradients for everyone",
    "section": "Why so many backends?",
    "text": "Why so many backends?\n\nConflicting paradigms:\n\nnumeric vs. symbolic vs. algorithmic\noperator overloading vs. source-to-source (which source?)\n\nCover varying subsets of the language\nHistorical reasons: developed by different people"
  },
  {
    "objectID": "index.html#meaningful-criteria",
    "href": "index.html#meaningful-criteria",
    "title": "Gradients for everyone",
    "section": "Meaningful criteria",
    "text": "Meaningful criteria\n\nDoes this AD backend execute without error?\nDoes it return the right derivative?\nDoes it run fast enough for me?"
  },
  {
    "objectID": "index.html#a-simple-decision-tree",
    "href": "index.html#a-simple-decision-tree",
    "title": "Gradients for everyone",
    "section": "A simple decision tree",
    "text": "A simple decision tree\n\nFollow recommendations of high-level library (e.g. Flux).\nOtherwise, choose mode based on input and output dimensions.\nTry the most battle-tested backends: ForwardDiff or Enzyme in forward mode, Zygote or Enzyme in reverse mode.\nIf nothing works, fall back on finite differences."
  },
  {
    "objectID": "index.html#typical-ad-failures-1",
    "href": "index.html#typical-ad-failures-1",
    "title": "Gradients for everyone",
    "section": "Typical AD failures (1)",
    "text": "Typical AD failures (1)\n\nimport ForwardDiff\n\nbadcopy(x) = copyto!(zeros(size(x)), x)\nForwardDiff.jacobian(badcopy, ones(2))\n\nMethodError: MethodError(Float64, (Dual{ForwardDiff.Tag{typeof(Main.Notebook.badcopy), Float64}}(1.0,1.0,0.0),), 0x0000000000007b04)\nMethodError: no method matching Float64(::ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2})\n\nClosest candidates are:\n  (::Type{T})(::Real, !Matched::RoundingMode) where T&lt;:AbstractFloat\n   @ Base rounding.jl:207\n  (::Type{T})(::T) where T&lt;:Number\n   @ Core boot.jl:792\n  Float64(!Matched::IrrationalConstants.Sqrt2)\n   @ IrrationalConstants ~/.julia/packages/IrrationalConstants/vp5v4/src/macro.jl:112\n  ...\n\nStacktrace:\n  [1] convert(::Type{Float64}, x::ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2})\n    @ Base ./number.jl:7\n  [2] setindex!(A::Vector{Float64}, x::ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}, i1::Int64)\n    @ Base ./array.jl:1021\n  [3] _unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::Vector{ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}}, soffs::Int64, n::Int64)\n    @ Base ./array.jl:299\n  [4] unsafe_copyto!\n    @ ./array.jl:353 [inlined]\n  [5] _copyto_impl!\n    @ ./array.jl:376 [inlined]\n  [6] copyto!\n    @ ./array.jl:363 [inlined]\n  [7] copyto!\n    @ ./array.jl:385 [inlined]\n  [8] badcopy(x::Vector{ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}})\n    @ Main.Notebook ~/work/JuliaCon2024-AutoDiff/JuliaCon2024-AutoDiff/index.qmd:223\n  [9] vector_mode_dual_eval!\n    @ ~/.julia/packages/ForwardDiff/PcZ48/src/apiutils.jl:24 [inlined]\n [10] vector_mode_jacobian(f::typeof(badcopy), x::Vector{Float64}, cfg::ForwardDiff.JacobianConfig{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2, Vector{ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}}})\n    @ ForwardDiff ~/.julia/packages/ForwardDiff/PcZ48/src/jacobian.jl:125\n [11] jacobian(f::Function, x::Vector{Float64}, cfg::ForwardDiff.JacobianConfig{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2, Vector{ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}}}, ::Val{true})\n    @ ForwardDiff ~/.julia/packages/ForwardDiff/PcZ48/src/jacobian.jl:21\n [12] jacobian(f::Function, x::Vector{Float64}, cfg::ForwardDiff.JacobianConfig{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2, Vector{ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}}})\n    @ ForwardDiff ~/.julia/packages/ForwardDiff/PcZ48/src/jacobian.jl:19\n [13] top-level scope\n    @ ~/work/JuliaCon2024-AutoDiff/JuliaCon2024-AutoDiff/index.qmd:224"
  },
  {
    "objectID": "index.html#typical-ad-failures-2",
    "href": "index.html#typical-ad-failures-2",
    "title": "Gradients for everyone",
    "section": "Typical AD failures (2)",
    "text": "Typical AD failures (2)\n\nimport Zygote\n\nZygote.jacobian(badcopy, ones(2))[1]\n\nErrorException: ErrorException(\"Mutating arrays is not supported -- called copyto!(Vector{Float64}, ...)\\nThis error occurs when you ask Zygote to differentiate operations that change\\nthe elements of arrays in place (e.g. setting values with x .= ...)\\n\\nPossible fixes:\\n- avoid mutating operations (preferred)\\n- or read the documentation and solutions for this error\\n  https://fluxml.ai/Zygote.jl/latest/limitations\\n\")\nMutating arrays is not supported -- called copyto!(Vector{Float64}, ...)\nThis error occurs when you ask Zygote to differentiate operations that change\nthe elements of arrays in place (e.g. setting values with x .= ...)\n\nPossible fixes:\n- avoid mutating operations (preferred)\n- or read the documentation and solutions for this error\n  https://fluxml.ai/Zygote.jl/latest/limitations\n\nStacktrace:\n  [1] error(s::String)\n    @ Base ./error.jl:35\n  [2] _throw_mutation_error(f::Function, args::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/lib/array.jl:70\n  [3] (::Zygote.var\"#543#544\"{Vector{Float64}})(::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/lib/array.jl:85\n  [4] (::Zygote.var\"#2633#back#545\"{Zygote.var\"#543#544\"{Vector{Float64}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/ZygoteRules/M4xmc/src/adjoint.jl:72\n  [5] badcopy\n    @ ~/work/JuliaCon2024-AutoDiff/JuliaCon2024-AutoDiff/index.qmd:223 [inlined]\n  [6] (::Zygote.Pullback{Tuple{typeof(badcopy), Vector{Float64}}, Tuple{Zygote.var\"#2633#back#545\"{Zygote.var\"#543#544\"{Vector{Float64}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/compiler/interface2.jl:0\n  [7] (::Zygote.var\"#291#292\"{Tuple{Tuple{Nothing}}, Zygote.Pullback{Tuple{typeof(badcopy), Vector{Float64}}, Tuple{Zygote.var\"#2633#back#545\"{Zygote.var\"#543#544\"{Vector{Float64}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/lib/lib.jl:206\n  [8] (::Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing}}, Zygote.Pullback{Tuple{typeof(badcopy), Vector{Float64}}, Tuple{Zygote.var\"#2633#back#545\"{Zygote.var\"#543#544\"{Vector{Float64}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}}}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/ZygoteRules/M4xmc/src/adjoint.jl:72\n  [9] call_composed\n    @ ./operators.jl:1045 [inlined]\n [10] (::Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Any})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/compiler/interface2.jl:0\n [11] call_composed\n    @ ./operators.jl:1044 [inlined]\n [12] #_#103\n    @ ./operators.jl:1041 [inlined]\n [13] (::Zygote.Pullback{Tuple{Base.var\"##_#103\", @Kwargs{}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(Zygote._jvec), typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Tuple{Zygote.var\"#2141#back#281\"{Zygote.var\"#277#280\"}, Zygote.Pullback{Tuple{typeof(Zygote._jvec), Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(vec), Vector{Float64}}, Tuple{}}}}, Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Any}, Zygote.var\"#2029#back#213\"{Zygote.var\"#back#211\"{2, 1, Zygote.Context{false}, typeof(Zygote._jvec)}}}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}}, Tuple{Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:inner, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(badcopy)}}, Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing}, Tuple{Nothing}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(badcopy)}, Tuple{Zygote.var\"#2013#back#204\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(badcopy)}, Tuple{}}}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(Zygote._jvec)}, Tuple{Zygote.var\"#2013#back#204\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(Zygote._jvec)}, Tuple{}}}}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:outer, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(Zygote._jvec)}}}}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/compiler/interface2.jl:0\n [14] #291\n    @ ~/.julia/packages/Zygote/nsBv0/src/lib/lib.jl:206 [inlined]\n [15] #2169#back\n    @ ~/.julia/packages/ZygoteRules/M4xmc/src/adjoint.jl:72 [inlined]\n [16] ComposedFunction\n    @ ./operators.jl:1041 [inlined]\n [17] (::Zygote.Pullback{Tuple{ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, Vector{Float64}}, Tuple{Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing, Nothing}, Tuple{Nothing}}, Zygote.Pullback{Tuple{Base.var\"##_#103\", @Kwargs{}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(Zygote._jvec), typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Tuple{Zygote.var\"#2141#back#281\"{Zygote.var\"#277#280\"}, Zygote.Pullback{Tuple{typeof(Zygote._jvec), Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(vec), Vector{Float64}}, Tuple{}}}}, Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Any}, Zygote.var\"#2029#back#213\"{Zygote.var\"#back#211\"{2, 1, Zygote.Context{false}, typeof(Zygote._jvec)}}}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}}, Tuple{Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:inner, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(badcopy)}}, Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing}, Tuple{Nothing}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(badcopy)}, Tuple{Zygote.var\"#2013#back#204\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(badcopy)}, Tuple{}}}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(Zygote._jvec)}, Tuple{Zygote.var\"#2013#back#204\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(Zygote._jvec)}, Tuple{}}}}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:outer, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(Zygote._jvec)}}}}}}}}, Zygote.var\"#2366#back#419\"{Zygote.var\"#pairs_namedtuple_pullback#418\"{(), @NamedTuple{}}}, Zygote.Pullback{Tuple{Type{NamedTuple}}, Tuple{}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/compiler/interface2.jl:0\n [18] (::Zygote.var\"#75#76\"{Zygote.Pullback{Tuple{ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, Vector{Float64}}, Tuple{Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing, Nothing}, Tuple{Nothing}}, Zygote.Pullback{Tuple{Base.var\"##_#103\", @Kwargs{}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(Zygote._jvec), typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Tuple{Zygote.var\"#2141#back#281\"{Zygote.var\"#277#280\"}, Zygote.Pullback{Tuple{typeof(Zygote._jvec), Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(vec), Vector{Float64}}, Tuple{}}}}, Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Any}, Zygote.var\"#2029#back#213\"{Zygote.var\"#back#211\"{2, 1, Zygote.Context{false}, typeof(Zygote._jvec)}}}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}}, Tuple{Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:inner, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(badcopy)}}, Zygote.var\"#2169#back#293\"{Zygote.var\"#291#292\"{Tuple{Tuple{Nothing}, Tuple{Nothing}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(badcopy)}, Tuple{Zygote.var\"#2013#back#204\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(badcopy)}, Tuple{}}}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(Zygote._jvec)}, Tuple{Zygote.var\"#2013#back#204\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(Zygote._jvec)}, Tuple{}}}}, Zygote.var\"#2180#back#303\"{Zygote.var\"#back#302\"{:outer, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(Zygote._jvec)}}}}}}}}, Zygote.var\"#2366#back#419\"{Zygote.var\"#pairs_namedtuple_pullback#418\"{(), @NamedTuple{}}}, Zygote.Pullback{Tuple{Type{NamedTuple}}, Tuple{}}, Zygote.var\"#2013#back#204\"{typeof(identity)}}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/compiler/interface.jl:91\n [19] withjacobian(f::Function, args::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/lib/grad.jl:150\n [20] jacobian(f::Function, args::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/nsBv0/src/lib/grad.jl:128\n [21] top-level scope\n    @ ~/work/JuliaCon2024-AutoDiff/JuliaCon2024-AutoDiff/index.qmd:236"
  },
  {
    "objectID": "index.html#typical-ad-failures-3",
    "href": "index.html#typical-ad-failures-3",
    "title": "Gradients for everyone",
    "section": "Typical AD failures (3)",
    "text": "Typical AD failures (3)\n\nimport Enzyme\n\nEnzyme.autodiff(\n  Enzyme.Forward,\n  copyto!,\n  Enzyme.Const(zeros(2)),\n  Enzyme.Duplicated(ones(2), zeros(2))\n)\n\nEnzyme.Compiler.EnzymeRuntimeException: Enzyme.Compiler.EnzymeRuntimeException(Cstring(0x00007f398952d6d4))\nEnzyme.Compiler.EnzymeRuntimeException(Cstring(0x00007f398952d6d4))\nStacktrace:\n  [1] throwerr(cstr::Cstring)\n    @ Enzyme.Compiler ~/.julia/packages/Enzyme/baiSZ/src/compiler.jl:1620\n  [2] copyto!\n    @ ./array.jl:368 [inlined]\n  [3] copyto!\n    @ ./array.jl:388 [inlined]\n  [4] fwddiffejulia_copyto__2894wrap\n    @ ./array.jl:0\n  [5] macro expansion\n    @ ~/.julia/packages/Enzyme/baiSZ/src/compiler.jl:6606 [inlined]\n  [6] enzyme_call\n    @ ~/.julia/packages/Enzyme/baiSZ/src/compiler.jl:6207 [inlined]\n  [7] ForwardModeThunk\n    @ ~/.julia/packages/Enzyme/baiSZ/src/compiler.jl:6087 [inlined]\n  [8] autodiff\n    @ ~/.julia/packages/Enzyme/baiSZ/src/Enzyme.jl:417 [inlined]\n  [9] autodiff\n    @ ~/.julia/packages/Enzyme/baiSZ/src/Enzyme.jl:333 [inlined]\n [10] autodiff(::EnzymeCore.ForwardMode{EnzymeCore.FFIABI}, ::typeof(copyto!), ::EnzymeCore.Const{Vector{Float64}}, ::EnzymeCore.Duplicated{Vector{Float64}})\n    @ Enzyme ~/.julia/packages/Enzyme/baiSZ/src/Enzyme.jl:318\n [11] top-level scope\n    @ ~/work/JuliaCon2024-AutoDiff/JuliaCon2024-AutoDiff/index.qmd:248"
  },
  {
    "objectID": "index.html#forwarddiff-troubleshooting",
    "href": "index.html#forwarddiff-troubleshooting",
    "title": "Gradients for everyone",
    "section": "ForwardDiff troubleshooting",
    "text": "ForwardDiff troubleshooting\nAllow numbers of type Dual in your functions.\n\ngoodcopy(x::AbstractArray{&lt;:Real}) = copyto!(zeros(eltype(x), size(x)), x)\nForwardDiff.jacobian(goodcopy, ones(2))\n\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0"
  },
  {
    "objectID": "index.html#zygote-troubleshooting",
    "href": "index.html#zygote-troubleshooting",
    "title": "Gradients for everyone",
    "section": "Zygote troubleshooting",
    "text": "Zygote troubleshooting\nDefine a custom rule with ChainRulesCore:\n\nusing ChainRulesCore, LinearAlgebra\n\nbadcopy2(x) = badcopy(x)\n\nfunction ChainRulesCore.rrule(::typeof(badcopy2), x)\n    @info \"My rule is called\"\n    y = badcopy2(x)  # primal value\n    function badcopy2_pullback(dy)\n    @info \"My pullback is called\"\n        df = NoTangent()\n        dx = I' * dy # Vector-Jacobian product\n        return (df, dx)\n    end\n    return y, badcopy2_pullback\nend\n\nZygote.jacobian(badcopy2, ones(2))\n\n[ Info: My rule is called\n[ Info: My pullback is called\n[ Info: My pullback is called\n\n\n([1.0 0.0; 0.0 1.0],)"
  },
  {
    "objectID": "index.html#enzyme-troubleshooting",
    "href": "index.html#enzyme-troubleshooting",
    "title": "Gradients for everyone",
    "section": "Enzyme troubleshooting",
    "text": "Enzyme troubleshooting\nPay attention to type stability, temporary storage and activity annotations (see the FAQ).\nEnzyme.autodiff(\n  Enzyme.Forward,\n  copyto!,\n  Enzyme.Duplicated(zeros(2), zeros(2)),\n  Enzyme.Duplicated(ones(2), zeros(2))\n)"
  },
  {
    "objectID": "index.html#goals",
    "href": "index.html#goals",
    "title": "Gradients for everyone",
    "section": "Goals",
    "text": "Goals\n\nDifferentiationInterface (DI) offers a common syntax for all AD backends1\nAD users can compare correctness and performance without reading each documentation\nAD developers get access to a wider user base\n\n\n\n\n\n\n\nThe fine print\n\n\nDI may be slower than a direct call to the backend’s API (mostly with Enzyme).\n\n\n\ninspired by AbstractDifferentiation"
  },
  {
    "objectID": "index.html#supported-packages",
    "href": "index.html#supported-packages",
    "title": "Gradients for everyone",
    "section": "Supported packages",
    "text": "Supported packages\n\n\n\n\nChainRulesCore\nDiffractor\nEnzyme\nFastDifferentiation\nFiniteDiff\nFiniteDifferences\nForwardDiff\n\n\n\nPolyesterForwardDiff\nReverseDiff\nSymbolics\nTapir\nTracker\nZygote"
  },
  {
    "objectID": "index.html#getting-started-with-di",
    "href": "index.html#getting-started-with-di",
    "title": "Gradients for everyone",
    "section": "Getting started with DI",
    "text": "Getting started with DI\nStep 1: load the necessary packages\n\nusing DifferentiationInterface\nimport ForwardDiff, Enzyme, Zygote\n\nf(x) = sum(abs2, x)\nx = [1.0, 2.0, 3.0, 4.0]\n\nStep 2: Combine DI’s operators with a backend from ADTypes\n\nvalue_and_gradient(f, AutoForwardDiff(), x)\n\n(30.0, [2.0, 4.0, 6.0, 8.0])\n\n\n\nvalue_and_gradient(f, AutoEnzyme(), x)\n\n(30.0, [2.0, 4.0, 6.0, 8.0])\n\n\n\nvalue_and_gradient(f, AutoZygote(), x)\n\n(30.0, [2.0, 4.0, 6.0, 8.0])\n\n\nStep 3: Increase performance via DI’s preparation mechanism"
  },
  {
    "objectID": "index.html#differentiationinterfacetest",
    "href": "index.html#differentiationinterfacetest",
    "title": "Gradients for everyone",
    "section": "DifferentiationInterfaceTest",
    "text": "DifferentiationInterfaceTest\n\nSystematic tests for a variety of inputs and functions\nScenarios with weird arrays (static, GPU, sparse)\nType-stability checks\nAutomated benchmarks"
  },
  {
    "objectID": "index.html#sparse-ad-ecosystem",
    "href": "index.html#sparse-ad-ecosystem",
    "title": "Gradients for everyone",
    "section": "Sparse AD ecosystem",
    "text": "Sparse AD ecosystem\n\nSparseConnectivityTracer for sparsity pattern detection\nSparseMatrixColorings for matrix coloring\nDI for sparse Jacobians and Hessians (see tutorial)\n\n\nSparse AD with coloring (Gebremedhin, Manne, and Pothen 2005)"
  },
  {
    "objectID": "index.html#whats-next",
    "href": "index.html#whats-next",
    "title": "Gradients for everyone",
    "section": "What’s next?",
    "text": "What’s next?\nDI and its sparse AD ecosystem are brand new projects:\n\nTry them out in your code\nReport bugs or inefficiencies\nHelp us improve these packages!\n\n\n\n\n\n\n\nComing up in DI\n\n\nSupport for multiple arguments and non-array types."
  },
  {
    "objectID": "index.html#more-complex-settings",
    "href": "index.html#more-complex-settings",
    "title": "Gradients for everyone",
    "section": "More complex settings",
    "text": "More complex settings\n\nAD through a simple function\nAD through an integral?\nAD through an optimization solver?\nAD through a stochastic expectation?"
  },
  {
    "objectID": "index.html#take-home-message",
    "href": "index.html#take-home-message",
    "title": "Gradients for everyone",
    "section": "Take-home message",
    "text": "Take-home message\nComputing derivatives is easy, but each AD solution comes with its own limitations.\nLearn to recognize and overcome them, either as a user or as a developer."
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Gradients for everyone",
    "section": "References",
    "text": "References\n\n\nBlondel, Mathieu, and Vincent Roulet. 2024. “The Elements of Differentiable Programming.” arXiv. https://doi.org/10.48550/arXiv.2403.14606.\n\n\nGebremedhin, Assefaw Hadish, Fredrik Manne, and Alex Pothen. 2005. “What Color Is Your Jacobian? Graph Coloring for Computing Derivatives.” SIAM Review 47 (4): 629–705. https://doi.org/cmwds4."
  },
  {
    "objectID": "ideas.html",
    "href": "ideas.html",
    "title": "JuliaCon talk on AD",
    "section": "",
    "text": "The state of automatic differentiation in Julia\nAutodiff in Julia from the user perspective\nA quick guide to autodiff in Julia\nA quick tour of AD in Julia\nNavigating the Julia AD ecosystem\nAD in Julia: A Beginner’s Guide to Backends and Beyond\nFrom Basics to Backends: A Complete Guide to Automatic Differentiation in Julia\n\n\n\n\n\nComplexity of the Julia ecosystem\n\nNumber of backends can be overwhelming / confusing (just open https://juliadiff.org/)\n\nDevs: Which backend do you use?\nUsers: Which function/method is differentiable with which backend?\n\nLots of folklore in Julia community\n\nA quick taxonomy of AD systems\n\nWe want gradients and more generally Jacobians\nAD systems only compute VJPs and JVPs\n\nFor function \\(f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m\\)\n\n\\(n\\) JVPs to compute Jacobian\n\\(m\\) VJPs to compute Jacobian (\\(m=1\\) for e.g. neural networks with scalar loss)\n\nVJPs and JVPs compose really really well due to the chain rule\nwe are not actually allocating potential huge Jacobian matrices but working with functions\n\nfunctions computing JVPs: pushforwards\nfunctions computing VJPs: pullbacks\n\ngood way to broadly categorize AD systems\n\nthere are other exotic approaches\n\nStructure of Autodiff in Julia (compared to e.g. Python) “Julia Dreams Big”\n\nAmbitious goal: language-wide AD\n\nPackages use different AD “backends”\n\nPyTorch and JAX: sub-ecosystems\n\nAD “backends” have their own ecosystems\n\n\nReverse-mode’s “two language problem”\n\nDifferent ways to write Julia code (see “1.5 language problem”)\nIn autodiff it’s reversed (Zygote doesn’t support mutation)\n\nUsing Julia AD in 2024\n\nThere are three types of users:\n\npeople developing AD systems\npeople who want to make their functions differentiable\npeople who want to differentiate over a function\n\nAD developers\nMaking functions differentiable\n\nProbably want compatibility with as many backends as possible\nHow do you do this with ChainRules, Enzyme, ForwardDiff while being fast?\nIs it even possible to have code differentiable across all backends?\n\nDifferentiating over a function\n\nWhich backend is compatible with my problem?\nWhich backend is the fastest?\n\n\nThe solutions (?)\n\nReverse-diff over mutating code being solved by Enzyme\n\nWhy don’t we all just use Enzyme? Complicated interface\n\nAbstractDiff / Diff’Interface\n\nAbstract API allows quickly testing all backends and benchmarking them against each other\n\n\n\n\n\n\n\nhttps://adrianhill.de/julia-ml-course/L6_Automatic_Differentiation/\nhttps://jax.readthedocs.io/en/latest/notebooks/autodiff_cookbook.html"
  },
  {
    "objectID": "ideas.html#title",
    "href": "ideas.html#title",
    "title": "JuliaCon talk on AD",
    "section": "",
    "text": "The state of automatic differentiation in Julia\nAutodiff in Julia from the user perspective\nA quick guide to autodiff in Julia\nA quick tour of AD in Julia\nNavigating the Julia AD ecosystem\nAD in Julia: A Beginner’s Guide to Backends and Beyond\nFrom Basics to Backends: A Complete Guide to Automatic Differentiation in Julia"
  },
  {
    "objectID": "ideas.html#draft-outline",
    "href": "ideas.html#draft-outline",
    "title": "JuliaCon talk on AD",
    "section": "",
    "text": "Complexity of the Julia ecosystem\n\nNumber of backends can be overwhelming / confusing (just open https://juliadiff.org/)\n\nDevs: Which backend do you use?\nUsers: Which function/method is differentiable with which backend?\n\nLots of folklore in Julia community\n\nA quick taxonomy of AD systems\n\nWe want gradients and more generally Jacobians\nAD systems only compute VJPs and JVPs\n\nFor function \\(f: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m\\)\n\n\\(n\\) JVPs to compute Jacobian\n\\(m\\) VJPs to compute Jacobian (\\(m=1\\) for e.g. neural networks with scalar loss)\n\nVJPs and JVPs compose really really well due to the chain rule\nwe are not actually allocating potential huge Jacobian matrices but working with functions\n\nfunctions computing JVPs: pushforwards\nfunctions computing VJPs: pullbacks\n\ngood way to broadly categorize AD systems\n\nthere are other exotic approaches\n\nStructure of Autodiff in Julia (compared to e.g. Python) “Julia Dreams Big”\n\nAmbitious goal: language-wide AD\n\nPackages use different AD “backends”\n\nPyTorch and JAX: sub-ecosystems\n\nAD “backends” have their own ecosystems\n\n\nReverse-mode’s “two language problem”\n\nDifferent ways to write Julia code (see “1.5 language problem”)\nIn autodiff it’s reversed (Zygote doesn’t support mutation)\n\nUsing Julia AD in 2024\n\nThere are three types of users:\n\npeople developing AD systems\npeople who want to make their functions differentiable\npeople who want to differentiate over a function\n\nAD developers\nMaking functions differentiable\n\nProbably want compatibility with as many backends as possible\nHow do you do this with ChainRules, Enzyme, ForwardDiff while being fast?\nIs it even possible to have code differentiable across all backends?\n\nDifferentiating over a function\n\nWhich backend is compatible with my problem?\nWhich backend is the fastest?\n\n\nThe solutions (?)\n\nReverse-diff over mutating code being solved by Enzyme\n\nWhy don’t we all just use Enzyme? Complicated interface\n\nAbstractDiff / Diff’Interface\n\nAbstract API allows quickly testing all backends and benchmarking them against each other"
  },
  {
    "objectID": "ideas.html#sources",
    "href": "ideas.html#sources",
    "title": "JuliaCon talk on AD",
    "section": "",
    "text": "https://adrianhill.de/julia-ml-course/L6_Automatic_Differentiation/\nhttps://jax.readthedocs.io/en/latest/notebooks/autodiff_cookbook.html"
  }
]